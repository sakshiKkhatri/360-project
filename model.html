<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>360 + GLB â€” Realistic Standing Model</title>

  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-orbit-controls-component@0.3.0/dist/aframe-orbit-controls-component.min.js"></script>

  <style>
    :root{
      --ui-bg: rgba(0,0,0,0.45);
      --btn-bg: rgba(255,255,255,0.08);
      --btn-radius: 10px;
      --btn-padding: 10px 12px;
      --safe-bottom: env(safe-area-inset-bottom, 12px);
    }
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Inter,system-ui,Arial}
    a-scene{width:100%;height:100vh;display:block}
    /* Controls */
    #controls{position:absolute;z-index:1500;display:flex;gap:8px;flex-wrap:wrap;pointer-events:auto}
    @media (min-width:701px) { #controls{ left:12px; top:12px;} }
    @media (max-width:700px) { #controls{ left:50%; bottom:calc(var(--safe-bottom)+12px); transform:translateX(-50%); } }
    .btn{ background:var(--btn-bg); border:1px solid rgba(255,255,255,0.06); color:#fff; padding:var(--btn-padding); border-radius:var(--btn-radius); cursor:pointer; font-size:14px; }
    .btn:active{ transform:translateY(1px); }
    #info{ position:absolute; right:12px; top:12px; z-index:1400; background:var(--ui-bg); padding:8px 12px; border-radius:10px; font-size:13px; }
    @media (max-width:700px){ #info { display:none; } }
    /* contact shadow style (on-screen helper) */
    #hint { position:absolute; left:12px; bottom:12px; z-index:1600; background:var(--ui-bg); padding:6px 8px; border-radius:8px; font-size:12px; }
  </style>
</head>
<body>

  <div id="controls" role="toolbar">
    <button id="modeBtn" class="btn">View model</button>
    <button id="resetBtn" class="btn">Reset</button>
    <button id="fullscreenBtn" class="btn">Fullscreen</button>
    <button id="enterVrBtn" class="btn">Enter VR</button>
  </div>

  <div id="info">Mode: <span id="modeLabel">Panorama</span></div>
  <div id="hint">Model scaled to approx. human height (1.7 m). Toggle to Model view to inspect.</div>

  <a-scene embedded vr-mode-ui="enabled:true" background="color:#000">
    <a-assets>
      <img id="panorama" src="image.jpg" crossorigin="anonymous" alt="panorama">
      <a-asset-item id="modelAsset" src="example-model.glb"></a-asset-item>
      <!-- tiny radial gradient texture for contact shadow (generated inline SVG data URI) -->
      <img id="shadowTex" crossorigin="anonymous" src='data:image/svg+xml;utf8,
        <svg xmlns="http://www.w3.org/2000/svg" width="512" height="512">
          <defs>
            <radialGradient id="g" cx="50%" cy="40%" r="50%">
              <stop offset="0%" stop-color="black" stop-opacity="0.65"/>
              <stop offset="55%" stop-color="black" stop-opacity="0.25"/>
              <stop offset="100%" stop-color="black" stop-opacity="0"/>
            </radialGradient>
          </defs>
          <rect width="100%" height="100%" fill="url(%23g)"/>
        </svg>'>
    </a-assets>

    <!-- Panorama sky -->
    <a-sky id="sky" src="#panorama" rotation="0 -90 0" material="shader:flat"></a-sky>

    <!-- Camera: default panorama look-controls; in Model mode we swap in orbit-controls -->
    <a-entity id="cameraRig">
      <a-entity id="mainCamera" camera="fov:60" position="0 1.65 0" 
                look-controls="enabled:true; magicWindowTrackingEnabled:true">
      </a-entity>
    </a-entity>

    <!-- Lighting: hemisphere + directional to make model look natural in scene -->
    <a-entity light="type: hemisphere; skyColor: #ffffff; groundColor: #666666; intensity: 0.9"></a-entity>
    <a-entity light="type: directional; intensity: 1.2" position="1 4 2" rotation="-40 30 0"></a-entity>
    <a-entity light="type: directional; intensity: 0.5" position="-2 1 -1"></a-entity>

    <!-- Optional (invisible) ground for collisions / reference; keep invisible to avoid visible grey plane -->
    <a-plane id="ground" rotation="-90 0 0" width="200" height="200" color="#000" visible="false"></a-plane>

    <!-- Contact shadow: textured circle placed under the model, aligned to modelRoot world xz -->
    <a-entity id="contactShadow" geometry="primitive: circle; radius: 1.0" rotation="-90 0 0" position="0 0.01 0" material="src:#shadowTex; transparent:true; opacity:0.9; side:double" visible="false"></a-entity>

    <!-- Model root: auto-fit will center and scale the model to ~1.7m tall and place base at y=0 -->
    <!-- initial local position a few meters forward so it doesn't block panorama view -->
    <a-entity id="modelRoot" position="0 0 -3" rotation="0 0 0" scale="1 1 1" visible="false" gltf-model="#modelAsset"></a-entity>
  </a-scene>

<script>
/* Viewer behavior
 - Auto-fit model to target height (meters) and center it on the ground (y=0)
 - Place a soft contact shadow under the model and keep it aligned with model's XZ
 - Toggle between Panorama and Model (orbit) modes
 - Reset, Fullscreen, Enter VR
*/
(function(){
  const TARGET_HEIGHT = 1.7; // target human height in meters for the model top -> adjust if needed

  const modeBtn = document.getElementById('modeBtn');
  const resetBtn = document.getElementById('resetBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const enterVrBtn = document.getElementById('enterVrBtn');
  const modeLabel = document.getElementById('modeLabel');

  const sceneEl = document.querySelector('a-scene');
  const cameraEl = document.getElementById('mainCamera');
  const modelRoot = document.getElementById('modelRoot');
  const contactShadow = document.getElementById('contactShadow');

  let mode = 'panorama'; // 'panorama' or 'model'
  let fitted = false;
  let modelCenter = { x:0, y:0, z:0 };
  let lastShadowRadius = 1.0;

  function setMode(newMode){
    if(newMode === mode) return;
    mode = newMode;
    modeLabel.textContent = mode === 'panorama' ? 'Panorama' : 'Model';
    if(mode === 'model'){
      // disable look-controls, enable orbit-controls and frame the model
      cameraEl.removeAttribute('look-controls');
      const target = `${modelCenter.x} ${modelCenter.y} ${modelCenter.z}`;
      cameraEl.setAttribute('orbit-controls', `target: ${target}; enableDamping: true; dampingFactor: 0.125; rotateSpeed: 0.6; enableZoom:true; minDistance:0.5; maxDistance:20`);
      // position camera at eye height a few meters back from model center
      cameraEl.object3D.position.set(modelCenter.x, Math.max(modelCenter.y + 1.5, 1.6), modelCenter.z + Math.max(1.8, 1.8));
    } else {
      // restore look controls and camera to panorama eye height
      cameraEl.removeAttribute('orbit-controls');
      cameraEl.setAttribute('look-controls','enabled:true; magicWindowTrackingEnabled:true');
      cameraEl.object3D.position.set(0, 1.65, 0);
    }
  }

  modeBtn.addEventListener('click', () => setMode(mode === 'panorama' ? 'model' : 'panorama'));
  resetBtn.addEventListener('click', () => {
    setMode('panorama');
    cameraEl.object3D.position.set(0,1.65,0);
    cameraEl.setAttribute('orbit-controls', 'target:0 0 0');
    // reset model local transform to fitted original position
    // we'll re-run fitting if needed
    if(fitted) {
      // no-op (model is already centered); if you want to force re-fit, reload asset or implement re-fit handler.
      modelRoot.object3D.position.set(0,0,-3);
      modelRoot.object3D.rotation.set(0,0,0);
    }
  });

  fullscreenBtn.addEventListener('click', () => {
    if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  });

  enterVrBtn.addEventListener('click', async () => {
    try {
      if(sceneEl.is('vr-mode')) sceneEl.exitVR();
      else await sceneEl.enterVR();
    } catch(e) {
      alert('VR requires HTTPS/localhost and a compatible device/browser.');
    }
  });

  // When the model loads, compute bounding box, scale the model
  modelRoot.addEventListener('model-loaded', (ev) => {
    try {
      // loaded THREE object
      const loaded = ev.detail && ev.detail.model ? ev.detail.model : modelRoot.getObject3D('mesh') || modelRoot.getObject3D('gltf');
      const obj = (loaded && loaded.scene) ? loaded.scene : loaded;
      if(!obj) {
        console.warn('Model object not found, cannot auto-fit.');
        modelRoot.setAttribute('visible', true);
        return;
      }

      // compute bounding box of object
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      // compute natural model height (max y - min y)
      const modelHeight = size.y || 1.0;

      // target scale so modelHeight becomes TARGET_HEIGHT
      const scaleFactor = TARGET_HEIGHT / modelHeight;

      // apply centering and scale:
      // 1) move so that the model's bottom sits at y=0 (on the scene floor)
      const minY = box.min.y;
      // translate object so minY -> 0, and center.x,z -> 0 (so model base is centered)
      obj.position.x -= center.x;
      obj.position.z -= center.z;
      obj.position.y -= minY;

      // 2) scale uniformly to desired height
      modelRoot.object3D.scale.setScalar(scaleFactor);

      // recompute bounding box after transforms
      const box2 = new THREE.Box3().setFromObject(obj);
      const size2 = new THREE.Vector3(); const center2 = new THREE.Vector3();
      box2.getSize(size2); box2.getCenter(center2);

      // store center (in modelRoot local coordinates)
      modelCenter = { x: center2.x, y: center2.y, z: center2.z };

      // show model and contact shadow
      modelRoot.setAttribute('visible', true);
      contactShadow.setAttribute('visible', true);

      // compute a reasonable shadow radius (based on model footprint)
      const footprint = Math.max(size2.x, size2.z) * 0.6;
      const shadowRadius = Math.max(0.35, footprint);
      contactShadow.setAttribute('geometry', `primitive: circle; radius: ${shadowRadius}`);
      contactShadow.object3D.position.set(center2.x, 0.01, center2.z);
      contactShadow.object3D.rotation.set(-Math.PI/2, 0, 0);
      contactShadow.object3D.scale.set(1,1,1);
      lastShadowRadius = shadowRadius;

      fitted = true;
      console.log('Auto-fit complete. modelHeight:', modelHeight, 'scaleFactor:', scaleFactor, 'modelCenter:', modelCenter);
    } catch (err) {
      console.error('Auto-fit failed:', err);
      modelRoot.setAttribute('visible', true);
    }
  });

  // keep contact shadow aligned to model each frame (in case model moves/animates)
  sceneEl.addEventListener('renderstart', () => {
    sceneEl.addEventListener('frame', () => {
      if(!fitted) return;
      // modelRoot.object3D may have children; compute world position for shadow origin
      const worldPos = new THREE.Vector3();
      modelRoot.object3D.getWorldPosition(worldPos);
      // place contactShadow at same XZ but y just above floor
      contactShadow.object3D.position.set(worldPos.x, 0.01, worldPos.z);
      // optionally, scale shadow a tiny bit if model scale changes
      // (we already set geometry radius at fit time)
    });
  });

  // start in panorama mode
  setTimeout(() => setMode('panorama'), 50);

  // helper setMode used in several places
  function setMode(m){
    if(m === mode) return;
    mode = m;
    modeLabel.textContent = (mode === 'panorama') ? 'Panorama' : 'Model';
    if(mode === 'model'){
      cameraEl.removeAttribute('look-controls');
      const target = `${modelCenter.x} ${modelCenter.y} ${modelCenter.z}`;
      cameraEl.setAttribute('orbit-controls', `target: ${target}; enableDamping: true; dampingFactor: 0.125; rotateSpeed: 0.6; enableZoom:true; minDistance:0.5; maxDistance:20`);
      cameraEl.object3D.position.set(modelCenter.x, Math.max(modelCenter.y + 1.5, 1.6), modelCenter.z + 2.0);
    } else {
      cameraEl.removeAttribute('orbit-controls');
      cameraEl.setAttribute('look-controls','enabled:true; magicWindowTrackingEnabled:true');
      cameraEl.object3D.position.set(0, 1.65, 0);
    }
  }

  // expose setMode to buttons
  window.setMode = setMode;

})();
</script>

</body>
</html>
