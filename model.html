<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>GLB Model Viewer — auto-fit</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
  <!-- Orbit controls -->
  <script src="https://unpkg.com/aframe-orbit-controls-component@0.3.0/dist/aframe-orbit-controls-component.min.js"></script>

  <style>
    :root {
      --ui-bg: rgba(0,0,0,0.45);
      --btn-bg: rgba(255,255,255,0.08);
      --btn-radius: 12px;
      --btn-padding: 10px 12px;
      --safe-bottom: env(safe-area-inset-bottom, 12px);
    }
    html,body { height:100%; margin:0; background:#111; color:#fff; font-family:Inter,system-ui,Arial; }
    #controls { position:absolute; z-index:1500; display:flex; gap:10px; flex-wrap:wrap; }
    @media (min-width:701px){ #controls{ left:12px; top:12px; } }
    @media (max-width:700px){ #controls{ left:50%; bottom:calc(var(--safe-bottom)+14px); transform:translateX(-50%); } }
    .btn{ background:var(--btn-bg); border:1px solid rgba(255,255,255,0.06); color:#fff; padding:var(--btn-padding); border-radius:var(--btn-radius); cursor:pointer; font-size:14px; }
    .btn:active{ transform:translateY(1px); }
    #modelName{ position:absolute; right:12px; top:12px; z-index:1400; background:var(--ui-bg); padding:8px 12px; border-radius:10px; font-size:13px; }
    @media (max-width:700px){ #modelName{ display:none; } }
    a-scene{ width:100%; height:100vh; display:block; }
  </style>
</head>
<body>

  <div id="controls">
    <button id="resetBtn" class="btn">Reset</button>
    <button id="fullscreenBtn" class="btn">Fullscreen</button>
    <button id="enterVrBtn" class="btn">Enter VR</button>
  </div>

  <div id="modelName">Loading: example-model.glb</div>

  <a-scene id="scene" embedded vr-mode-ui="enabled:true" background="color:#000">
    <a-assets>
      <a-asset-item id="defaultModel" src="example-model.glb"></a-asset-item>
    </a-assets>

    <!-- Camera with orbit controls -->
    <a-entity id="cameraRig">
      <a-entity id="camera" camera position="0 1.6 3"
                orbit-controls="target: 0 1 0; enableDamping: true; dampingFactor:0.125; rotateSpeed:0.6; autoRotate: false; enableZoom:true; minDistance:0.4; maxDistance:50">
      </a-entity>
    </a-entity>

    <!-- Lighting (added stronger directional lights) -->
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; intensity: 1.0" position="1 3 2"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="-2 1 -1"></a-entity>

    <!-- Ground (visual anchor; optional) -->
    <a-plane rotation="-90 0 0" width="50" height="50" color="#222" material="roughness:1;metalness:0"></a-plane>

    <!-- Model root: we load model into this and then adjust transforms -->
    <a-entity id="modelRoot" visible="true" position="0 0 0" rotation="0 0 0" scale="1 1 1" gltf-model="#defaultModel"></a-entity>
  </a-scene>

<script>
  // Auto-fit helper: centers, scales, and positions camera to frame model
  (function(){
    const modelRoot = document.getElementById('modelRoot');
    const cameraEl = document.getElementById('camera');
    const modelName = document.getElementById('modelName');
    const scene = document.getElementById('scene');

    function safeNumber(v){ return (typeof v === 'number' && isFinite(v)) ? v : 0; }

    modelRoot.addEventListener('model-loaded', (evt) => {
      try {
        modelName.textContent = 'Loaded: example-model.glb';
        // evt.detail.model is the loaded object (THREE.Group)
        const obj = evt.detail && evt.detail.model ? evt.detail.model : modelRoot.getObject3D('mesh') || modelRoot.getObject3D('gltf');
        // prefer the glTF scene if present
        const threeObject = obj.scene || obj;
        if (!threeObject) {
          console.warn('Loaded model object not found in event.detail.model — falling back to modelRoot.object3D');
        }

        // compute bbox
        const box = new THREE.Box3().setFromObject(threeObject);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        // defensive fallback
        const maxDim = Math.max( safeNumber(size.x), safeNumber(size.y), safeNumber(size.z), 0.001 );

        // 1) recentre model so its center is at origin and its base sits at y=0
        // shift = -center ; then lift so base is at y=0: add half-height
        const shiftX = -center.x;
        const shiftY = -center.y + (size.y/2 || 0);
        const shiftZ = -center.z;
        // apply to the model's top-level object; prefer modelRoot.object3D children
        threeObject.position.x += shiftX;
        threeObject.position.y += shiftY;
        threeObject.position.z += shiftZ;

        // If the model root has a parent (it will), we don't move modelRoot but the object's position inside it.
        // Some glTFs attach at child[0], so ensure we position the top-level group:
        // (the code above updates the loaded object's position directly)

        // 2) scale model to reasonable size if necessary (normalize so maxDim ~ 1)
        // only scale if model is absurdly big (>10) or tiny (<0.05)
        let scaleFactor = 1;
        if (maxDim > 10) scaleFactor = 1.0 / maxDim * 2.0; // shrink
        if (maxDim < 0.05) scaleFactor = 1.0 / maxDim * 0.8; // grow
        if (scaleFactor !== 1) {
          modelRoot.object3D.scale.setScalar(scaleFactor);
        }

        // recompute bounding box after transform/scale
        const box2 = new THREE.Box3().setFromObject(threeObject);
        const size2 = new THREE.Vector3();
        const center2 = new THREE.Vector3();
        box2.getSize(size2);
        box2.getCenter(center2);

        // 3) place modelRoot such that models base is near y=0
        // compute desired camera distance: use size2 diagonal
        const maxDim2 = Math.max(size2.x, size2.y, size2.z, 0.001);
        const fov = (cameraEl.getAttribute('camera') && cameraEl.getAttribute('camera').fov) ? cameraEl.getAttribute('camera').fov : 50;
        const fovRad = THREE.MathUtils.degToRad(fov);
        // distance formula to fit model in view: distance = (maxDim2/2) / tan(fov/2) * padding
        const distance = (maxDim2 * 0.6) / Math.tan(fovRad / 2);
        // position camera at (center.x, center.y + size2.y*0.5, center.z + distance)
        const camX = center2.x;
        const camY = Math.max(center2.y + size2.y * 0.5, 0.6);
        const camZ = center2.z + distance * 1.1; // small extra padding

        // apply camera position
        cameraEl.object3D.position.set(camX, camY, camZ);
        // update orbit-controls target to center of model
        cameraEl.setAttribute('orbit-controls', 'target', `${center2.x} ${center2.y} ${center2.z}`);

        // Make sure modelRoot is visible
        modelRoot.setAttribute('visible', true);

        console.log('Model auto-fit complete — size:', size2, 'center:', center2, 'camera positioned to:', camX, camY, camZ);
      } catch (err) {
        console.error('Auto-fit error:', err);
      }
    });

    // If model fails to load, show message
    modelRoot.addEventListener('error', (e) => {
      console.error('Model load error', e);
      modelName.textContent = 'Model failed to load — check console';
    });

    // Reset logic: bring camera back to a sane default
    document.getElementById('resetBtn').addEventListener('click', () => {
      cameraEl.object3D.position.set(0, 1.6, 3);
      cameraEl.setAttribute('orbit-controls', 'target', '0 1 0');
      console.log('Reset camera');
    });

    // Fullscreen
    document.getElementById('fullscreenBtn').addEventListener('click', () => {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
      else document.exitFullscreen?.();
    });

    // VR entry
    document.getElementById('enterVrBtn').addEventListener('click', async () => {
      try {
        if (scene.is('vr-mode')) scene.exitVR();
        else await scene.enterVR();
      } catch (err) {
        alert('Enter VR failed — use HTTPS / compatible device. See console for details.');
        console.warn(err);
      }
    });

    // helpful logging
    console.log('Viewer ready — waiting for model-loaded event.');
  })();
</script>

</body>
</html>
